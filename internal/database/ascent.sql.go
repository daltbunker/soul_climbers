// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: ascent.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createOrUpdateAscent = `-- name: CreateOrUpdateAscent :one
INSERT INTO ascent(grade, rating, ascent_date, over_200_pounds, attempts, comment, created_by, climb_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8) 
ON CONFLICT ON CONSTRAINT ascent_pkey 
DO UPDATE SET
    grade = $1,
    rating = $2,
    ascent_date = $3,
    over_200_pounds = $4,
    attempts = $5,
    comment = $6,
    created_by = $7,
    updated_at = now() 
RETURNING climb_id, grade, rating, attempts, over_200_pounds, comment, ascent_date, created_by, created_at, updated_at
`

type CreateOrUpdateAscentParams struct {
	Grade         string
	Rating        string
	AscentDate    time.Time
	Over200Pounds bool
	Attempts      string
	Comment       sql.NullString
	CreatedBy     int32
	ClimbID       int32
}

func (q *Queries) CreateOrUpdateAscent(ctx context.Context, arg CreateOrUpdateAscentParams) (Ascent, error) {
	row := q.db.QueryRowContext(ctx, createOrUpdateAscent,
		arg.Grade,
		arg.Rating,
		arg.AscentDate,
		arg.Over200Pounds,
		arg.Attempts,
		arg.Comment,
		arg.CreatedBy,
		arg.ClimbID,
	)
	var i Ascent
	err := row.Scan(
		&i.ClimbID,
		&i.Grade,
		&i.Rating,
		&i.Attempts,
		&i.Over200Pounds,
		&i.Comment,
		&i.AscentDate,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAscent = `-- name: DeleteAscent :one
DELETE FROM ascent
WHERE created_by = $1
AND climb_id = $2
RETURNING climb_id, grade, rating, attempts, over_200_pounds, comment, ascent_date, created_by, created_at, updated_at
`

type DeleteAscentParams struct {
	CreatedBy int32
	ClimbID   int32
}

func (q *Queries) DeleteAscent(ctx context.Context, arg DeleteAscentParams) (Ascent, error) {
	row := q.db.QueryRowContext(ctx, deleteAscent, arg.CreatedBy, arg.ClimbID)
	var i Ascent
	err := row.Scan(
		&i.ClimbID,
		&i.Grade,
		&i.Rating,
		&i.Attempts,
		&i.Over200Pounds,
		&i.Comment,
		&i.AscentDate,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAscentsByClimb = `-- name: GetAscentsByClimb :many
SELECT a.grade, a.rating, TO_CHAR(a.ascent_date, 'YYYY-MM-DD') as ascent_date, a.over_200_pounds, a.attempts, a.comment, u.username
FROM ascent a
INNER JOIN users u
  ON u.users_id = a.created_by
WHERE a.climb_id = $1
`

type GetAscentsByClimbRow struct {
	Grade         string
	Rating        string
	AscentDate    string
	Over200Pounds bool
	Attempts      string
	Comment       sql.NullString
	Username      string
}

func (q *Queries) GetAscentsByClimb(ctx context.Context, climbID int32) ([]GetAscentsByClimbRow, error) {
	rows, err := q.db.QueryContext(ctx, getAscentsByClimb, climbID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAscentsByClimbRow
	for rows.Next() {
		var i GetAscentsByClimbRow
		if err := rows.Scan(
			&i.Grade,
			&i.Rating,
			&i.AscentDate,
			&i.Over200Pounds,
			&i.Attempts,
			&i.Comment,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
